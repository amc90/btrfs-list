#! /usr/bin/perl -T
use strict;
use warnings;
use IPC::Open3;
use Symbol 'gensym';
use Data::Dumper;

$ENV{'PATH'} = '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin';

#my $dev = shift;
my @cmd;
my %filesystems;
my %vol;
my $debug = $ENV{'DEBUG'} ? 1 : 0;

my $nosnap = shift;
if ($nosnap and $nosnap eq '-s')
{
	$nosnap = 1;
}
else
{
	$nosnap = 0;
}

sub debug
{
  $debug or return;
  foreach (@_)
  {
    print STDERR $_."\n";
  }
}

sub run_cmd
{
  my $flags = shift;
  my @args = @_;
  my ($_stdin, $_stdout, $_stderr);
  $_stderr = gensym;
  debug("about to run_cmd ['".join("','", @args)."']");
  my $pid = open3($_stdin, $_stdout, $_stderr, @args);
  debug("waiting for cmd to complete...");
  my @stdout = ();
  my @stderr = ();
  while (<$_stdout>)
  {
    chomp;
    debug("stdout: ".$_);
    /WARNING:/ and print STDERR $_."\n";
    push @stdout, $_;
  }
  while (<$_stderr>)
  {
    chomp;
    debug("stderr: ".$_);
    /WARNING:/ and print STDERR $_."\n";
    if (not $flags->{'silent_stderr'}) { print join(' ', @args).": stderr: ".$_."\n"; }
    push @stderr, $_;
  }
  waitpid( $pid, 0 );
  my $child_exit_status = $? >> 8;
  debug("cmd return status is $child_exit_status");
  if ($flags->{'fatal'})
  {
    print STDERR "FATAL: the command [".join(' ', @args)."] returned a non-zero status ($child_exit_status)\n";
    foreach (@stdout)
    {
      print STDERR "FATAL: stdout: ".$_."\n";
    }
    foreach (@stderr)
    {
      print STDERR "FATAL: stdout: ".$_."\n";
    }
    exit 1;
  }
  return ( $child_exit_status, \@stdout, \@stderr );
}

my %readlinkcache = ();
sub link2real
{
  my $dev = shift;
  if (defined $readlinkcache{$dev})
  {
    return $readlinkcache{$dev};
  }
	my @cmd = run_cmd( { can_fail => 1 }, qw{ readlink -f }, $dev );
  if (defined $cmd[1][0])
  {
    $readlinkcache{$dev} = $cmd[1][0];
    return $readlinkcache{$dev};
  }
  return $dev;
}

sub raw2human

{
	my $human = shift;
	if ($human !~ /^(\d+)(\.\d+)?$/) { return $human; }
	$human = $1;
	if    ($human > 1024**6) { $human = sprintf('%.2fE', $human/1024**6); }
	elsif ($human > 1024**5) { $human = sprintf('%.2fP', $human/1024**5); }
	elsif ($human > 1024**4) { $human = sprintf('%.2fT', $human/1024**4); }
	elsif ($human > 1024**3) { $human = sprintf('%.2fG', $human/1024**3); }
	elsif ($human > 1024**2) { $human = sprintf('%.2fM', $human/1024**2); }
	elsif ($human > 1024**1) { $human = sprintf('%.2fK', $human/1024**1); }
	return $human;
}

@cmd = run_cmd({ can_fail => 0 }, qw{ btrfs --version } );
my ($version) = $cmd[1][0] =~ /v([0-9.]+)/;

if ($version lt '3.16')
{
	print STDERR "WARNING: you're using an old version of btrfs-progs (v$version, but v3.16+ is recommended), available information will be limited.\n";
}

@cmd = run_cmd( { can_fail => 0 }, qw{ uname -r } );
my ($kerver) = $cmd[1][0] =~ /^([0-9]+\.[0-9]+)/;
if ($kerver lt $version)
{
	print STDERR "WARNING: your kernel seems older (v$kerver.x) than the btrfs-progs userspace tool (v$version), some features might not be supported.\n";
}

if ($< ne 0)
{
	print STDERR "FATAL: you must be root to use this command\n";
	exit 1;
}


=cut
# btrfs filesystem show
Label: 'beurre'  uuid: 010705d8-430f-4f5b-9315-12df40677e97
Total devices 4 FS bytes used 18.23MiB
devid    1 size 250.00MiB used 176.00MiB path /dev/loop1
devid    2 size 250.00MiB used 164.00MiB path /dev/loop2
devid    3 size 250.00MiB used 164.00MiB path /dev/loop3
devid    4 size 250.00MiB used 164.00MiB path /dev/loop4
=cut

@cmd = run_cmd({ can_fail => 0 }, qw{ btrfs filesystem show } );
my ($label,$fuuid);
foreach (@{ $cmd[1] })
{
	if (/^Label:\s+(\S+)\s+uuid:\s+([0-9a-f-]+)/)
	{
		$label = $1;
		$fuuid = $2;
	}
	if (defined $fuuid and m{devid\s.+path\s+(\S+)})
	{
    my $dev = $1;
		if (not exists $filesystems{$fuuid})
		{
			$filesystems{$fuuid} = { uuid => $fuuid, label => $label, devices => [] };
		}
#READLINK
		if (-l $dev)
		{
			$dev = link2real($dev);
		}
		push @{ $filesystems{$fuuid}{'devices'} }, $dev;
	}
}
debug(Dumper \%filesystems);

# now look for the mountpoint

my %mountpoints;
open(MP, '/proc/mounts');
while (<MP>)
{
	if (m{^(\S+)\s+(\S+)})
	{
# ugly fix for /dev/mapper/stuff being a sylink to ../dm-xxx
		my $dev = $1;
		my $mp = $2;
		$mountpoints{$dev} = $mp;
		if (-l $dev)
		{
		  $mountpoints{ link2real($dev) } = $mp;
		}
	}
}
close(MP);

foreach my $fuuid (keys %filesystems)
{
	foreach my $dev (@{ $filesystems{$fuuid}{'devices'} || [] })
	{
		if (exists $mountpoints{$dev})
		{
			$filesystems{$fuuid}{'mountpoint'} = $mountpoints{$dev};
			last;
		}
	}
}

$ENV{'DEBUG'} and print Dumper \%filesystems;

# lets cvol btrfs
=cut
ID      gen     cgen    parent  top depth       parent_uuid     received_uuid   uuid    path
--      ---     ----    ------  ---------       -----------     -------------   ----    ----
257     17      11      5       5               -       -       9bc47c09-fe59-4b4c-8ed6-b01a941bfd75    sub1
=cut

my $oldprog = 0;
foreach my $fuuid (keys %filesystems)
{
	my $mp = $filesystems{$fuuid}{'mountpoint'};
	defined $mp or next;
	-d $mp or next;
# cvol df
	my $hasraid56 = 0;
	@cmd = run_cmd( { can_fail => 1, silent_stderr => 1 }, qw{ btrfs filesystem df --raw }, $mp );
	if (not @{ $cmd[1] } or $cmd[0])
	{
		@cmd = run_cmd( { can_fail => 0 }, qw{ btrfs filesystem df }, $mp );
	}
	my ($total,$used) = (0,0);
	foreach (@{ $cmd[1] })
	{
		/RAID[56]/ and $hasraid56++;
		if (/^Data[^,]*, (\S+):\s+total=([^,]+), used=([^,]+)/)
		{
			#Data, RAID5: total=2977486077952, used=2962325794816
			$total += $2;
			$used += $3;
			# FIXME if $2 $3 are not numbers ?
		}
	}
	my $free = raw2human($total - $used);
	$vol{$fuuid}{df} = {
		id => '-1',
		path => $filesystems{$fuuid}{label},
		gen => 0,
		cgen => 0,
		parent => '-',
		top => '-',
		puuid => '*',
		ruuid => '-', type => 'fidf', mode => 'rw',
		rfer => "-",
		excl => raw2human($used),
		free => $free,
	};
# classic df for raid56
	if ($hasraid56)
	{
		@cmd = run_cmd( { can_fail => 0 }, qw{ df --block-size=1 }, $mp);
		foreach (@{ $cmd[1] })
		{
			# /dev/mapper/luks-WDC_WD30EZRX-00MMMB0_WD-WCAWZ3013164 9001772654592 3292893921280 3580264464384  48% /tank
			if (/\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)%/)
			{
				($total,$used,$free) = ($1,$2,$3);
				#FIXME only for raid5 with 3 devs, TODO :
				$used = $used / 3 * 2;
				$free = $free / 3 * 2;
				$vol{$fuuid}{df} = {
					id => '-1',
					path => $filesystems{$fuuid}{label},
					gen => 0,
					cgen => 0,
					parent => '-',
					top => '-',
					puuid => '*',
					ruuid => '-', type => 'df', mode => 'rw',
					rfer => "-",
					excl => raw2human($used),
					free => raw2human($free),
				};
				last;
			}
		}
	}
# cvol btrfs sub list
	@cmd = run_cmd( { can_fail => 1, silent_stderr => 1 }, qw{ btrfs subvolume list -pacguq }, $mp);
# ID 3332 gen 81668 cgen 2039 parent 0 top level 0 parent_uuid 9fafce5e-6f45-3b44-bf72-6f94897217d4 uuid 20b76a70-dd70-b843-8265-a321ba4a5b61 path <FS_TREE>/DELETED
# ID 1911 gen 81668 cgen 929 parent 5 top level 5 parent_uuid - uuid aec0705e-6cae-a941-854c-d95e0a36ba2c path main
	if ($cmd[0] or not @{ $cmd[1] })
	{
# old btrfsprogs...
		$oldprog = 1;
		@cmd = run_cmd( { can_fail => 0 }, qw{ btrfs subvolume list }, $mp);
	}
	foreach (@{ $cmd[1] })
	{
		my $vuuid = undef;
		if (/(\s|^)uuid ([0-9a-f-]+)/)
		{
			$vuuid = $2;
			if ($vuuid eq '-')
			{
# old btrfs kernel, recent btrfsprogs
				m{ID (\d+)} and $vuuid = $1;
			}
			$vol{$fuuid}{$vuuid}{uuid} = $vuuid;
		}
		elsif (/(\s|^)ID (\d+)/)
		{
# old btrfsprogs
			$vuuid = $2;
			$vol{$fuuid}{$vuuid}{uuid} = $vuuid;
		}
		else
		{
			next;
		}
# ID 257 gen 17 cgen 11 parent 5 top depth 5 parent_uuid - received_uuid - uuid 9bc47c09-fe59-4b4c-8ed6-b01a941bfd75 path sub1
		$vol{$fuuid}{$vuuid}{puuid} = '-'; # old btrfsprogs don't have puuid, set a sane default
		/(\s|^)ID (\d+)/            and $vol{$fuuid}{$vuuid}{id} = $2;
		/(\s|^)gen (\d+)/           and $vol{$fuuid}{$vuuid}{gen} = $2;
		/(\s|^)cgen (\d+)/          and $vol{$fuuid}{$vuuid}{cgen} = $2;
		/(\s|^)parent (\d+)/        and $vol{$fuuid}{$vuuid}{parent} = $2;
		/(\s|^)top_depth (\d+)/     and $vol{$fuuid}{$vuuid}{top} = $2;
		/(\s|^)parent_uuid (\S+)/   and $vol{$fuuid}{$vuuid}{puuid} = $2;
		/(\s|^)received_uuid (\S+)/ and $vol{$fuuid}{$vuuid}{ruuid} = $2;
		/(\s|^)path (\S+)/          and $vol{$fuuid}{$vuuid}{path} = $2;
		$vol{$fuuid}{$vuuid}{path} =~ s/^<FS_TREE>\///;
		$vol{$fuuid}{$vuuid}{type} = 'subvol'; # by default, will be overriden below
		if ($oldprog)
		{
			$vol{$fuuid}{$vuuid}{type} = 'vol?'; # old version can't tell vol/snap difference
		}
		# doesn't work with old btrfs kernel, do it other way
		#if ($vol{$fuuid}{$vuuid}{puuid} ne '-')
		#{
		#	$vol{$fuuid}{$vuuid}{type} = 'snap';
		#}
		$vol{$fuuid}{$vuuid}{mode} = 'rw'; # by default, will be overriden below
		$vol{$fuuid}{$vuuid}{rfer} = 0;
		$vol{$fuuid}{$vuuid}{excl} = 0;
	}
	if (not $oldprog)
	{
		@cmd = run_cmd( {}, qw{ btrfs subvolume list -pacguqs }, $mp);
		foreach (@{ $cmd[1] })
		{
			/(\s|^)uuid ([0-9a-f-]+)/ and exists $vol{$fuuid}{$2} and $vol{$fuuid}{$2}{type} = 'snap';
			/(\s|^)ID ([0-9]+)/       and exists $vol{$fuuid}{$2} and $vol{$fuuid}{$2}{type} = 'snap';
		}
		@cmd = run_cmd({}, qw{ btrfs subvolume list -pacguqr }, $mp);
		foreach (@{ $cmd[1] })
		{
			/(\s|^)uuid ([0-9a-f-]+)/ and exists $vol{$fuuid}{$2} and $vol{$fuuid}{$2}{mode} = 'ro';
			/(\s|^)ID ([0-9]+)/       and exists $vol{$fuuid}{$2} and $vol{$fuuid}{$2}{mode} = 'ro';
		}
	}
	$ENV{'DEBUG'} and print Dumper \$vol{$fuuid};
}

# get quota stuff

=cut
WARNING: Qgroup data inconsistent, rescan recommended
qgroupid         rfer         excl     max_rfer     max_excl parent  child
--------         ----         ----     --------     -------- ------  -----
0/5           7.99MiB      7.99MiB        0.00B        0.00B ---     ---
0/257        10.02MiB     10.01MiB        0.00B        0.00B ---     ---
=cut
foreach my $fuuid (keys %filesystems)
{
	my $mp = $filesystems{$fuuid}{'mountpoint'};
	defined $mp or next;
	-d $mp or next;
	$oldprog and next;

	@cmd = run_cmd( { can_fail => 1, silent_stderr => 1 }, qw{ btrfs quota rescan -s }, $mp);
	if ($cmd[1][0] and $cmd[1][0] =~ /operation running|current key/)
	{
		print STDERR "WARNING: a quota rescan is running, size information is not correct yet\n";
	}

	@cmd = run_cmd({ can_fail => 1, silent_stderr => 1 }, qw{ btrfs qgroup show -pcre --raw }, $mp);
	if ($cmd[0] or not @{ $cmd[1] })
	{
		@cmd = run_cmd( { can_fail => 1, silent_stderr => 1 }, qw{ btrfs qgroup show -pcre }, $mp);
	  if ($cmd[0] or not @{ $cmd[1] })
		{
			print STDERR "WARNING: can't get quota group info, either your kernel is too old, or you didn't enable quota (btrfs quota enable $mp)\n";
			next;
		}
	}
	foreach (@{ $cmd[1] })
	{
		if (m{^(\d+)/(\d+)\s+(\S+)\s+(\S+)})
		{
			my $qid = $1; my $id = $2; my $rfer = $3; my $excl = $4;
			$rfer = raw2human($rfer);
			$excl = raw2human($excl);
			if ($id < 256)
			{
				if (not exists $vol{$fuuid}{$id})
				{
					$vol{$fuuid}{$id} = {
						id => $id,
						path => $filesystems{$fuuid}{mountpoint},
						gen => 0,
						cgen => 0,
						parent => '-',
						top => '-',
						puuid => '+',
						ruuid => '-', type => 'vol', mode => 'rw'
					};
				}
				$vol{$fuuid}{$id}{rfer} = $rfer;
				$vol{$fuuid}{$id}{excl} = $excl;
				next;
			}
			foreach my $vuuid (keys %{ $vol{$fuuid} })
			{
				if ($id eq $vol{$fuuid}{$vuuid}{id})
				{
					$vol{$fuuid}{$vuuid}{rfer} = $rfer;
					$vol{$fuuid}{$vuuid}{excl} = $excl;
					last;
				}
			}
		}
	}
}
$ENV{'DEBUG'} and print Dumper \%vol;


# ok, now, do the magic
my @ordered = ();
my $maxdepth = 0;
my $biggestpath = 0;
sub dothemagic
{
	my $volumes = shift;
	my $depth = shift;
	my $parentuuid = shift;
	$depth > $maxdepth and $maxdepth = $depth;
	foreach my $vuuid (sort { $volumes->{$a}{id} <=> $volumes->{$b}{id} } keys %$volumes)
	{
		#$ENV{'DEBUG'} and print ".."x($depth) . " working on vuuid=$vuuid with parentuuid=$parentuuid and this uuidpuuid=".$volumes->{$vuuid}{puuid}."\n";
		if ($parentuuid eq $volumes->{$vuuid}{puuid})
		{
			my $hash = $volumes->{$vuuid};
			$hash->{'depth'} = $depth;
			length($hash->{path}) > $biggestpath and $biggestpath = length($hash->{path});
			push @ordered, $hash;
			dothemagic($volumes, $depth+1, $vuuid);# unless $parentuuid eq '-';
		}
	}
}

#print "ALRIGHT.\n";
foreach my $fuuid (keys %filesystems)
{
	@ordered = ();
	$maxdepth = 0;
	$biggestpath = 0;
	dothemagic($vol{$fuuid}, 0, '*');
	dothemagic($vol{$fuuid}, 1, '+');
	dothemagic($vol{$fuuid}, 1, '-');

# find the longest path (including leading spaces)
	my $longestpath = 0;
	foreach (@ordered)
	{
		my $len = $_->{depth} * 3;
		$len += length($_->{path});
		$len > $longestpath and $longestpath = $len;
	}

	my $format = "%-${longestpath}s %3s %8s %9s %9s %s\n";
	printf $format, 'PATH', 'ID', "TYPE", "REFER", "USED", "" ;
	foreach (@ordered)
	{
#print Dumper $_;
		if ($nosnap and $_->{'type'} eq 'snap') { next; }
		my $type = $_->{type};
		$_->{mode} eq 'ro' and $type = "ro".$type;
		my $rfer = $_->{rfer};
		$rfer =~ s/iB$//;
		my $excl = $_->{excl};
		$excl =~ s/iB$//;
		my $free = '';
		if (exists $_->{'free'})
		{
			$free = '('.$_->{'free'}.' free)';
		}
		printf $format,
		       " "x($_->{depth} * 3) . $_->{path},
		       $_->{id}, $type, $rfer, $excl, $free;
	}
}

